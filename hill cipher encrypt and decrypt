#include <stdio.h>
#include <string.h>

// Modulo 26 function
int mod26(int x) {
    return (x % 26 + 26) % 26;
}

// Modular inverse of a number modulo 26
int modInverse(int a) {
    for (int i = 1; i < 26; i++) {
        if ((a * i) % 26 == 1)
            return i;
    }
    return -1;
}

// Matrix inverse for 2x2 matrix modulo 26
int inverseKeyMatrix(int key[2][2], int inv[2][2]) {
    int det = mod26(key[0][0]*key[1][1] - key[0][1]*key[1][0]);
    int detInv = modInverse(det);
    if (detInv == -1) {
        printf("Key matrix is not invertible.\n");
        return 0;
    }
    inv[0][0] = mod26( key[1][1] * detInv);
    inv[0][1] = mod26(-key[0][1] * detInv);
    inv[1][0] = mod26(-key[1][0] * detInv);
    inv[1][1] = mod26( key[0][0] * detInv);
    return 1;
}

// Encrypt 2-letter blocks
void hillEncrypt(char* msg, int key[2][2]) {
    for (int i = 0; msg[i] && msg[i+1]; i += 2) {
        int a = msg[i] - 'a';
        int b = msg[i+1] - 'a';
        int x = mod26(key[0][0]*a + key[0][1]*b);
        int y = mod26(key[1][0]*a + key[1][1]*b);
        printf("%c%c", x + 'a', y + 'a');
    }
}

// Decrypt 2-letter blocks
void hillDecrypt(char* cipher, int key[2][2]) {
    int invKey[2][2];
    if (!inverseKeyMatrix(key, invKey)) return;

    for (int i = 0; cipher[i] && cipher[i+1]; i += 2) {
        int a = cipher[i] - 'a';
        int b = cipher[i+1] - 'a';
        int x = mod26(invKey[0][0]*a + invKey[0][1]*b);
        int y = mod26(invKey[1][0]*a + invKey[1][1]*b);
        printf("%c%c", x + 'a', y + 'a');
    }
}

int main() {
    int key[2][2] = {{9, 4}, {5, 7}};
    char plaintext[] = "helpme";
    char ciphertext[] = "zebbwq"; // this will be generated by encryption

    printf("Original plaintext: %s\n", plaintext);
    printf("Encrypted: ");
    hillEncrypt(plaintext, key);

    printf("\nDecrypted: ");
    hillDecrypt(ciphertext, key);
    printf("\n");
    return 0;
}
